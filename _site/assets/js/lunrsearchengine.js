
var documents = [{
    "id": 0,
    "url": "http://localhost:4000/study/404.html",
    "title": "404",
    "body": "404 Page does not exist!Please use the search bar at the top or visit our homepage! "
    }, {
    "id": 1,
    "url": "http://localhost:4000/study/about",
    "title": "About",
    "body": "안녕하세요!!: 이 블로그는 제가 학습한 내용을 정리하는 공간입니다.  (아마 다른 것도 올릴 것 같긴 합니다. . ) 재미있는 주제가 생기면 하나씩 올려보려고 합니다 ㅎㅎ 잘 부탁 드립니다! 소개:  이름: 박철영 (jyukki) 경력: 4년 차 백엔드 개발자 (프론트도 가아끔 하긴 합니다. . )연락처 &amp; SNS:  GitHub: github. com/jyukki97 Email: jyukki97@gmail. com이전 블로그:  https://jyukki97. github. io https://velog. io/@jyukki97/posts https://jyukki. tistory. com/"
    }, {
    "id": 2,
    "url": "http://localhost:4000/study/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 3,
    "url": "http://localhost:4000/study/",
    "title": "Home",
    "body": "      Featured:                                                                                                                                                                                                                       REST vs GraphQL 성능 비교                              :               저번 포스트에서 gRPC 와 REST, GraphQL 에 대해서 알아보았다. GraphQL 이 아직까지는 REST 를 버리고 갈만큼 매력적으로 다가오지않았는데, 혹시 다른 장점이 있을지 모르니 테스트 해보자. . . . :                                                                                                                                                                       jyukki                                15 Mar 2025                                                                                                                                                                                                                                                                                                                        REST vs gRPC 성능 비교: 정말 gRPC가 좋을까?                              :               gRPC는 REST보다 빠르다? 뭔가 지나가다 들었던 것 같은데 gRPC가 REST보다 성능이 좋다고 했던 것 같다. 단순한 API 호출에서 성능 차이가 있을까? 뭐. . 테스트 해보면 알겠지. . . :                                                                                                                                                                       jyukki                                09 Mar 2025                                                                                                                            All Stories:                                                             MySql Index 테스트 이모저모              :        귀찮아서 매번 B-Tree 만 쓰던 DB 인덱스가 갑자기 궁금해지기 시작했다. 다른 Index 도 쓸만할지 한번 확인해보자:                                                                               jyukki                15 Mar 2025                                                                                            Mono 내부에서 throw 를 던질 경우 onErrorResume이 동작하지 않는다?              :        개발 도중 Mono 내부에서 다른 이슈로 throw 가 던져졌는데, onErrorResume 을 무시하는 것을 발견했다. 테스트 해보자:                                                                               jyukki                15 Mar 2025                                                                                                                                     REST vs GraphQL 성능 비교              :        저번 포스트에서 gRPC 와 REST, GraphQL 에 대해서 알아보았다. GraphQL 이 아직까지는 REST 를 버리고 갈만큼 매력적으로 다가오지않았는데, 혹시 다른 장점이 있을지 모르니 테스트 해보자. :                                                                               jyukki                15 Mar 2025                                                                                            gRPC vs REST vs GraphQL: 무엇을 선택해야 할까?              :        저번 포스트에서 gRPC 와 REST 비교를 해봤다. 생각해보니 GraphQL 을 놓쳤었다. 안 써본 거라 제외하고 생각했던 것 같다. 이참에 세가지 한번 비교해보자:                                                                               jyukki                15 Mar 2025                                                                                                                                     REST vs gRPC 성능 비교: 정말 gRPC가 좋을까?              :        gRPC는 REST보다 빠르다?뭔가 지나가다 들었던 것 같은데 gRPC가 REST보다 성능이 좋다고 했던 것 같다. 단순한 API 호출에서 성능 차이가 있을까?뭐. . 테스트 해보면 알겠지 확인해보자. :                                                                               jyukki                09 Mar 2025                                                                                            새로운 시작              :       블로그를 새로 만들었습니다. :                                                                               jyukki                09 Mar 2025                                            "
    }, {
    "id": 4,
    "url": "http://localhost:4000/study/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 5,
    "url": "http://localhost:4000/study/4-mysql-index/",
    "title": "MySql Index 테스트 이모저모",
    "body": "2025/03/15 -  귀찮아서 매번 B-Tree 만 쓰던 DB 인덱스가 갑자기 궁금해지기 시작했다. 다른 Index 도 쓸만할지 한번 확인해보자 테이스 테이블: 12345678910CREATE TABLE test_index (  id INT AUTO_INCREMENT PRIMARY KEY,  created_at DATETIME DEFAULT CURRENT_TIMESTAMP, -- B-Tree 테스트  category VARCHAR(50), -- Hash Index 테스트  description TEXT, -- Fulltext Index 테스트  INDEX idx_btree_created_at (created_at),  INDEX idx_hash_category USING HASH (category),  FULLTEXT INDEX idx_fulltext_description (description));테스트 데이터: 123456789101112INSERT INTO test_index (created_at, category, description)SELECT  NOW() - INTERVAL FLOOR(RAND() * 365) DAY,  ELT(FLOOR(1 + (RAND() * 3)), 'A', 'B', 'C'),  CONCAT(    'This is a sample description ',    FLOOR(RAND() * 1000),    ' with random content'  )FROM information_schema. tables AS aCROSS JOIN information_schema. tables AS bLIMIT 100000;1. B-Tree 테스트: 범위 조회 (BETWEEN)12345EXPLAIN ANALYZESELECT * FROM test_indexWHERE created_at BETWEEN '2024-10-01' AND '2024-11-01';-&gt; Index range scan on test_index using idx_btree_created_at over ('2024-10-01 00:00:00' &lt;= created_at &lt;= '2024-11-01 00:00:00'), with index condition: (test_index. created_at between '2024-10-01' and '2024-11-01') (cost=3824 rows=8498) (actual time=0. 19. . 26. 6 rows=8498 loops=1)1234567EXPLAIN ANALYZESELECT * FROM test_indexIGNORE INDEX(idx_btree_created_at)   -- B-Tree 인덱스 제거WHERE created_at BETWEEN '2024-10-01' AND '2024-11-01';-&gt; Filter: (test_index. created_at between '2024-10-01' and '2024-11-01') (cost=10102 rows=11054) (actual time=0. 0711. . 66. 4 rows=8498 loops=1)  -&gt; Table scan on test_index (cost=10102 rows=99495) (actual time=0. 0548. . 42. 1 rows=100000 loops=1)검색 조회 (=)12345EXPLAIN ANALYZE SELECT * FROM test_index WHERE created_at='2025-01-01 06:53:52';-&gt; Index lookup on test_index using idx_btree_created_at (created_at=TIMESTAMP'2025-01-01 06:53:52') (cost=101 rows=288) (actual time=0. 0881. . 1. 49 rows=288 loops=1)1234567EXPLAIN ANALYZESELECT * FROM test_indexIGNORE INDEX(idx_btree_created_at)   -- B-Tree 인덱스 제거WHERE created_at='2025-01-01 06:53:52';| -&gt; Filter: (test_index. created_at = TIMESTAMP'2025-01-01 06:53:52') (cost=10102 rows=270) (actual time=0. 239. . 45. 8 rows=288 loops=1)  -&gt; Table scan on test_index (cost=10102 rows=99495) (actual time=0. 03. . 39. 5 rows=100000 loops=1)결과      항목   B-Tree   인덱스 X   차이점         범위 조회   26. 6ms   66. 4ms   2. 5배 차이       검색 조회   1. 49ms   45. 8ms   30배 차이    확실히 빠르긴하다. .  범위 조회 효율이 더 잘나올 줄 알았는데, 검색 효율도 나쁘지않다 아닌가? 데이터가 늘면 늘수록 인덱스 없는 범위 조회 시간은 많이 걸릴라나?2. Hash Index 테스트: 범위 조회 (BETWEEN)123456EXPLAIN ANALYZE SELECT * FROM test_index WHERE category BETWEEN 'A' AND 'B';-&gt; Filter: (test_index. category between 'A' and 'B') (cost=10102 rows=49747) (actual time=0. 0455. . 53. 5 rows=66775 loops=1)  -&gt; Table scan on test_index (cost=10102 rows=99495) (actual time=0. 0401. . 41 rows=100000 loops=1)1234567EXPLAIN ANALYZE SELECT * FROM test_index IGNORE INDEX(idx_hash_category)   -- Hash 인덱스 제거WHERE category BETWEEN 'A' AND 'B';| -&gt; Filter: (test_index. category between 'A' and 'B') (cost=10102 rows=11054) (actual time=0. 0491. . 53. 9 rows=66775 loops=1)  -&gt; Table scan on test_index (cost=10102 rows=99495) (actual time=0. 045. . 41. 2 rows=100000 loops=1)검색 조회 (=)12345EXPLAIN ANALYZE SELECT * FROM test_index WHERE category='B';-&gt; Index lookup on test_index using idx_hash_category (category='B') (cost=5431 rows=49747) (actual time=0. 0495. . 47. 8 rows=33477 loops=1)1234567EXPLAIN ANALYZE SELECT * FROM test_indexIGNORE INDEX(idx_hash_category)   -- Hash 인덱스 제거 WHERE category='B';-&gt; Filter: (test_index. category = 'B') (cost=10102 rows=49748) (actual time=0. 0344. . 25. 7 rows=33477 loops=1)  -&gt; Table scan on test_index (cost=10102 rows=99495) (actual time=0. 0323. . 21. 2 rows=100000 loops=1)결과      항목   Hash 인덱스   인덱스 X   차이점         범위 조회   53. 5ms   53. 9ms   X       검색 조회   47. 8ms   25. 7ms   2배 차이    ????? 검색 했는데 왜 Hash 인덱스가 더 느리지?. .  범위 조회가 안되는 대신 검색 조회 효율을 높이기 위해 사용하는 것 아니었나?? 흐음…. . 데이터가 A, B, C 뿐이라 해시 효율이 안나오나? 데이터를 바꿔보자2-1 Hash Index 테스트: 데이터 변경: 123456CREATE TABLE hash_test (  id INT AUTO_INCREMENT PRIMARY KEY,  uuid VARCHAR(36),  INDEX idx_hash_uuid USING HASH (uuid));123456INSERT INTO hash_test (uuid)SELECT   UUID()FROM information_schema. tables AS aCROSS JOIN information_schema. tables AS bLIMIT 100000;검색 조회 (=)123456EXPLAIN ANALYZE SELECT * FROM hash_test WHERE uuid='eaeaf92b-fb22-11ef-9745-0242ac110002';-&gt; Covering index lookup on hash_test using idx_hash_uuid (uuid='eaeaf92b-fb22-11ef-9745-0242ac110002') (cost=0. 35 rows=1) (actual time=0. 0349. . 0. 0403 rows=1 loops=1)12345678EXPLAIN ANALYZE SELECT * FROM hash_test IGNORE INDEX(idx_hash_uuid)    -- Hash 인덱스 제거 WHERE uuid='eaeaf92b-fb22-11ef-9745-0242ac110002';-&gt; Filter: (hash_test. uuid = 'eaeaf92b-fb22-11ef-9745-0242ac110002') (cost=10079 rows=1) (actual time=16. . 34. 3 rows=1 loops=1)  -&gt; Table scan on hash_test (cost=10079 rows=99750) (actual time=0. 303. . 23. 4 rows=100000 loops=1)결과      항목   Hash 인덱스   인덱스 X   차이점         검색 조회   0. 0403ms   34. 3ms   800배 차이    이게 옳게된 결과지 흐음. . 데이터에 따라 인덱스를 고르는 것도 신중히 해야할 듯 같은 값이 많으면 Hash 인덱스의 성능이 떨어진다!3. Fulltext Index 테스트: 검색 조회 (MATCH)123456EXPLAIN ANALYZESELECT * FROM test_indexWHERE MATCH(description) AGAINST('random');-&gt; Filter: (match test_index. `description` against ('random')) (cost=0. 35 rows=1) (actual time=15. 7. . 89. 4 rows=100000 loops=1)  -&gt; Full-text index search on test_index using idx_fulltext_description (description='random') (cost=0. 35 rows=1) (actual time=15. 7. . 85. 6 rows=100000 loops=1)1234567EXPLAIN ANALYZE SELECT * FROM test_index IGNORE INDEX(idx_fulltext_description)   -- Fulltext 인덱스 제거WHERE MATCH(description) AGAINST('random');-&gt; Filter: (match test_index. `description` against ('random')) (cost=10102 rows=11054) (actual time=0. 571. . 27. 3 rows=100000 loops=1)  -&gt; Table scan on test_index (cost=10102 rows=99495) (actual time=0. 568. . 19. 5 rows=100000 loops=1)검색 조회 (LIKE)123456EXPLAIN ANALYZE SELECT * FROM test_index WHERE description LIKE '%random%';-&gt; Filter: (test_index. `description` like '%random%') (cost=10102 rows=11054) (actual time=0. 0473. . 62. 9 rows=100000 loops=1)  -&gt; Table scan on test_index (cost=10102 rows=99495) (actual time=0. 0422. . 32. 8 rows=100000 loops=1)1234567EXPLAIN ANALYZE SELECT * FROM test_index IGNORE INDEX(idx_fulltext_description)    -- Fulltext 인덱스 제거WHERE description LIKE '%random%';-&gt; Filter: (test_index. `description` like '%random%') (cost=10102 rows=11054) (actual time=0. 052. . 70. 5 rows=100000 loops=1)  -&gt; Table scan on test_index (cost=10102 rows=99495) (actual time=0. 0452. . 36. 9 rows=100000 loops=1)결과      항목   Fulltext 인덱스   인덱스 X   차이점         검색 조회 (MATCH)   89. 4ms   27. 3ms   3배 차이       검색 조회 (LIKE)   62. 9ms   70. 5ms   X    일단 LIKE 검색은 Fulltext 인덱스가 안먹는구나 확인 MATCH 검색은 왜 또 인덱스 뺀게 더 빠를까….  으음… 또 데이터 문제일까? random 이라는 문구가 모든 row 에 존재해서 사실상 테이블 스캔이랑 동일하게 전체 검사를 하게 된건가?. . 3-1. Fulltext Index 테스트: 데이터 변경: 123456CREATE TABLE fulltext_test (   id INT AUTO_INCREMENT PRIMARY KEY,   description TEXT,     FULLTEXT INDEX idx_fulltext_description (description));1234567891011121314151617181920212223242526INSERT INTO fulltext_test (description)SELECT CONCAT(    ELT(FLOOR(1 + (RAND() * 5)),      'AI',      'Blockchain',      'Quantum Computing',      'Cybersecurity',      'Cloud Computing'    ),    ' is transforming the world of ',    ELT(FLOOR(1 + (RAND() * 5)),      'finance',      'healthcare',      'automotive',      'retail',      'education'    ),    '. Experts predict it will impact over ',    FLOOR(10 + (RAND() * 90)),    ' million users by ',    FLOOR(2025 + (RAND() * 10)),    '. '    )FROM information_schema. tables AS aCROSS JOIN information_schema. tables AS bLIMIT 1000000;검색 조회 (MATCH)123456EXPLAIN ANALYZESELECT * FROM fulltext_test WHERE MATCH(description) AGAINST('Blockchain'); -&gt; Filter: (match fulltext_test. `description` against ('Blockchain')) (cost=0. 35 rows=1) (actual time=5. 64. . 35. 9 rows=22668 loops=1)  -&gt; Full-text index search on fulltext_test using idx_fulltext_description (description='Blockchain') (cost=0. 35 rows=1) (actual time=5. 63. . 34. 3 rows=22668 loops=1)12345678EXPLAIN ANALYZE  SELECT * FROM fulltext_test IGNORE INDEX(idx_fulltext_description) WHERE MATCH(description) AGAINST('Blockchain'); -&gt; Filter: (match fulltext_test. `description` against ('Blockchain')) (cost=11596 rows=12572) (actual time=0. 046. . 48. 7 rows=22668 loops=1)  -&gt; Table scan on fulltext_test (cost=11596 rows=113155) (actual time=0. 0288. . 36. 6 rows=114244 loops=1)결과      항목   Fulltext 인덱스   인덱스 X   차이점         검색 조회 (MATCH)   35. 9ms   48. 7ms   1. 35배 차이    성능 향상이 있긴 하지만, 위에 B-Tree 나 Hash 만큼 드라마틱 하지는 않은 것 같다.  문장이 더 다양하고, 긴 문장이면 효과가 더 나올라나?4. B-Tree VS Hash Index:  생각보다 B-Tree 도 검색효율이 나오는 것 같아서 둘을 비교해보자범위 조회 (BETWEEN)123456EXPLAIN ANALYZE SELECT * FROM btree_hash_test WHERE btree_column BETWEEN 100000 AND 200000;-&gt; Index range scan on btree_hash_test using idx_btree over (100000 &lt;= btree_column &lt;= 200000), with index condition: (btree_hash_test. btree_column between 100000 and 200000) (cost=4535 rows=10078) (actual time=1. 62. . 11. 9 rows=10078 loops=1)123456EXPLAIN ANALYZE SELECT * FROM btree_hash_test WHERE hash_column BETWEEN 100000 AND 200000;-&gt; Index range scan on btree_hash_test using idx_hash over (100000 &lt;= hash_column &lt;= 200000), with index condition: (btree_hash_test. hash_column between 100000 and 200000) (cost=4475 rows=9943) (actual time=3. 58. . 21. 8 rows=9943 loops=1)검색 조회 (=)123456EXPLAIN ANALYZE SELECT * FROM btree_hash_test WHERE btree_column=146708;-&gt; Index lookup on btree_hash_test using idx_btree (btree_column=146708) (cost=0. 35 rows=1) (actual time=0. 0424. . 0. 0454 rows=1 loops=1)123456EXPLAIN ANALYZE SELECT * FROM btree_hash_test WHERE hash_column=921585;-&gt; Index lookup on btree_hash_test using idx_hash (hash_column=921585) (cost=0. 35 rows=1) (actual time=0. 0199. . 0. 0213 rows=1 loops=1)결과      항목   B-Tree   Hash 인덱스   차이점         범위 조회 (BETWEEN)   11. 9ms   21. 8ms   2배 차이       검색 조회 (=)   0. 0454ms   0. 0213ms   2배 차이    범위랑 검색 모두 2배 차이씩 나는 것 같다.  대충 범위 조회를 많이쓰면 B-Tree를 검색 조회를 많이 쓰면 Hash Index 를 사용하면 될 것 같다. 결과: 12그냥 대충 B-Tree 써도 손해는 없어보인다. 다만, 속도차이를 보니 속도를 타이트하게 잡아야한다면, 다른 Index 를 고려해볼 필요는 있을 것 같다. 나중에 더 해볼 것:  INSERT, UPDATE 시 속도 저하가 어느 정도인지 테스트 해보고싶다.  생각보다 Fulltext Index 테스트가 안좋았던 것 같다. 테스트 방식을 바꿔야 할 것 같다 =&gt; 크롤링으로 많은 데이터를 가져와서 Fulltext Index 걸어봐야 확실히 성능이 좋아지는지 알 수 있을 것 같다. "
    }, {
    "id": 6,
    "url": "http://localhost:4000/study/3-mono-throw/",
    "title": "Mono 내부에서 throw 를 던질 경우 onErrorResume이 동작하지 않는다?",
    "body": "2025/03/15 -  개발 도중 Mono 내부에서 다른 이슈로 throw 가 던져졌는데, onErrorResume 을 무시하는 것을 발견했다. 테스트 해보자 기본 테스트 코드: 1234Mono&lt;List&lt;String&gt;&gt; getNameList() {  throw new RuntimeException();}1234567891011121314151617@Testvoid test() {  getNameList(). map(nameList -&gt; {          System. out. println(nameList);          return nameList;        })        . flatMapMany(Flux::fromIterable)        . collectList()        . onErrorResume(e -&gt; {          System. out. println( error );          return Mono. just(List. of( error ));        })        . block();}// java. lang. RuntimeException Mono 내부에서 throw 를 던질경우 정상적으로 onErrorResume 을 통과하지 못한다.  아마 내부에서 throw 로 던질 경우 Mono 에서 감지하지 못하는 듯Mono. error 테스트: 123456Mono&lt;List&lt;String&gt;&gt; getNameList() {  return Mono. error(new RuntimeException( error ));}// 정상적으로 error 출력 이 경우에는 정상적으로 onErrorResume 을 통과했다.  테스트 코드는 정상인 듯throw 를 던져도 onErrorResume 을 통과하게 코드 수정: 1. try-catch 로 묶어서 Mono. error 반환: 12345678910Mono&lt;List&lt;String&gt;&gt; getNameList() {  try {    throw new RuntimeException();  } catch (Exception e) {    return Mono. error(e);  }}// 정상적으로 error 출력2. Mono 를 defer 로 감싸기: 1234Mono&lt;List&lt;String&gt;&gt; getNameList() {  throw new RuntimeException();}123456789101112131415161718@Testvoid test() {  Mono. defer(() -&gt; getNameList())    . map(nameList -&gt; {      System. out. println(nameList);      return nameList;    })    . flatMapMany(Flux::fromIterable)    . collectList()    . onErrorResume(e -&gt; {      System. out. println( error );      return Mono. just(List. of( error ));    })    . block();}// 정상적으로 error 출력 사실 이 방식이 왜 동작하는지는 잘 모르것다.  해결해보려고 이것저것 해보다가 되더라 뭐 되면 됐지 (try-catch 는 하고 싶지않았다…)"
    }, {
    "id": 7,
    "url": "http://localhost:4000/study/2-rest-vs-graphql/",
    "title": "REST vs GraphQL 성능 비교",
    "body": "2025/03/15 -  저번 포스트에서 gRPC 와 REST, GraphQL 에 대해서 알아보았다. GraphQL 이 아직까지는 REST 를 버리고 갈만큼 매력적으로 다가오지않았는데, 혹시 다른 장점이 있을지 모르니 테스트 해보자. list 조회: 12345678910wrk -t8 -c100 -d30s http://localhost:8080/posts// -------8 threads and 100 connectionsThread Stats  Avg   Stdev   Max  +/- Stdev Latency  143. 24ms  49. 04ms 589. 18ms  85. 56% Req/Sec  84. 58   18. 74  128. 00   74. 96%20234 requests in 30. 10s, 2. 53GB readRequests/sec:  672. 18Transfer/sec:   85. 93MB12345678910wrk -t8 -c100 -d30s -s . /test-grapql-post-list. lua http://localhost:8080/graphql// -------8 threads and 100 connectionsThread Stats  Avg   Stdev   Max  +/- Stdev Latency  225. 51ms  73. 18ms 850. 47ms  85. 31% Req/Sec  53. 34   18. 47  131. 00   71. 55%12770 requests in 30. 06s, 0. 90GB readRequests/sec:  424. 83Transfer/sec:   30. 70MB      비교 항목   REST API   GraphQL   비고         평균 응답 시간 (Latency)   143. 24ms   225. 51ms   1. 57배 느림       초당 요청 처리량 (Requests/sec)   672. 18 req/sec   424. 83 req/sec   1. 58배 낮음       최대 응답 시간 (Max Latency)   589. 18ms   850. 47ms           총 요청 수   2,0234 req   1,2770 req           데이터 전송량 (Transfer/sec)   85. 93MB/sec   30. 70MB/sec              Metric   REST API   GraphQL   비고         Average CPU Usage (%)   281. 98%   549. 1%   1. 95배 높음       Max CPU Usage (%)   328. 9%   632. 8%   1. 92배 높음    단건 조회 (댓글 포함): 12345678910wrk -t8 -c100 -d30s http://localhost:8080/posts/1// -------8 threads and 100 connectionsThread Stats  Avg   Stdev   Max  +/- Stdev Latency  22. 63ms  8. 89ms 105. 55ms  78. 00% Req/Sec  536. 37  113. 74   1. 32k  76. 25%128274 requests in 30. 08s, 44. 28MB readRequests/sec:  4264. 89Transfer/sec:   1. 47MB12345678910wrk -t8 -c100 -d30s -s . /test-grapql-post-comment. lua http://localhost:8080/graphql// -------8 threads and 100 connectionsThread Stats  Avg   Stdev   Max  +/- Stdev Latency  45. 72ms  14. 19ms 201. 01ms  86. 96% Req/Sec  263. 78   39. 41  450. 00   67. 62%63127 requests in 30. 05s, 32. 15MB readRequests/sec:  2100. 63Transfer/sec:   1. 07MB      비교 항목   REST API   GraphQL   비고         평균 응답 시간 (Latency)   22. 63ms   45. 72ms   2배 느림       초당 요청 처리량 (Requests/sec)   4264. 89 req/sec   2100. 63 req/sec   2배 낮음       최대 응답 시간 (Max Latency)   105. 55ms   201. 01ms           총 요청 수   128,274 req   63,127 req           데이터 전송량 (Transfer/sec)   1. 47MB/sec   1. 07MB/sec              Metric   REST API   GraphQL   비고         Average CPU Usage (%)   128. 75%   153. 2%   1. 19배 높음       Max CPU Usage (%)   148. 0%   172. 0%   1. 16배 높음   결론: 12345뭐랄까. . . GraphQL 은 느리고, CPU 도 많이 먹는 것 같다. . . REST 와 비교했을 때, 구현이 더 귀찮을 것을 생각하면, 일반적인 상황에서는 딱히 쓸 이유는 없어보인다. . GraphQL 의 성능을 생각해봤을 때에는 쓸 이유가 명확할 때에만 쓰게될 것 같다. "
    }, {
    "id": 8,
    "url": "http://localhost:4000/study/1-grpc-vs-rest-vs-graphql/",
    "title": "gRPC vs REST vs GraphQL: 무엇을 선택해야 할까?",
    "body": "2025/03/15 -  저번 포스트에서 gRPC 와 REST 비교를 해봤다. 생각해보니 GraphQL 을 놓쳤었다. 안 써본 거라 제외하고 생각했던 것 같다. 이참에 세가지 한번 비교해보자 1. gRPC, REST, GraphQL 개요: 개요는 chat GPT 가 정성을 다해 써줬다. 뭐 사실 이게 중요한건 아니니까 모르던 부분만 스윽 읽고 넘어가자 어짜피 실전파라 코드로 보는게 빠르더라. gRPC란?: gRPC(Google Remote Procedure Call)는 Google이 개발한 고성능 RPC(Remote Procedure Call) 프레임워크입니다. Protocol Buffers(ProtoBuf)를 사용하여 데이터를 직렬화하며, HTTP/2를 기반으로 빠르고 효율적인 통신을 제공합니다. gRPC 특징:  바이너리 데이터 직렬화 (ProtoBuf): JSON보다 빠르고 가벼운 데이터 전송 HTTP/2 기반: 다중 스트리밍, 헤더 압축 등을 지원하여 효율적인 네트워크 사용 자동 코드 생성: 클라이언트 및 서버 스텁을 자동으로 생성하여 개발 생산성 향상 양방향 스트리밍 지원: 서버와 클라이언트가 지속적으로 데이터를 주고받을 수 있음 다양한 언어 지원: Java, Python, Go, C++, Kotlin 등 다양한 언어에서 사용 가능REST란?: REST(Representational State Transfer)는 가장 널리 사용되는 API 설계 패턴으로, HTTP 프로토콜을 기반으로 클라이언트와 서버 간 통신을 수행합니다. REST 특징:  HTTP 기반: GET, POST, PUT, DELETE 등의 HTTP 메서드 사용 JSON 또는 XML 데이터 포맷: 일반적으로 JSON을 사용하여 데이터를 직렬화 Stateless(무상태성): 각 요청이 독립적이며, 서버는 클라이언트 상태를 유지하지 않음 캐싱 지원: HTTP 캐싱을 활용하여 성능 최적화 가능GraphQL이란?: GraphQL은 Facebook에서 개발한 API 쿼리 언어로, 클라이언트가 원하는 데이터를 정확하게 요청할 수 있도록 설계되었습니다. GraphQL 특징:  필요한 데이터만 요청: 오버페칭(over-fetching) 및 언더페칭(under-fetching) 문제 해결 단일 엔드포인트: 다양한 리소스를 하나의 API에서 제공 타입 시스템 제공: 명확한 스키마 정의를 통한 안정적인 API 제공 클라이언트 중심 API: 프론트엔드에서 필요한 데이터 구조를 직접 정의할 수 있음2. gRPC vs REST vs GraphQL 비교:       특징   gRPC   REST   GraphQL         전송 방식   HTTP/2 + ProtoBuf   HTTP/1. 1 + JSON   HTTP/1. 1 + JSON       속도   매우 빠름 (바이너리)   일반적 (텍스트)   REST보다 다소 느림 (쿼리 파싱 필요)       데이터 직렬화   ProtoBuf (바이너리)   JSON, XML   JSON       유연성   낮음 (고정된 메서드)   중간 (엔드포인트 기반)   높음 (필요한 데이터만 요청)       실시간 스트리밍   지원 (양방향)   제한적 (SSE, WebSocket 필요)   지원 (Subscription)       언어 지원   다양한 언어 지원   주로 웹 개발 중심   주로 웹 개발 중심       학습 곡선   높음   낮음   중간       사용 사례   마이크로서비스, 고성능 API   전통적인 웹 API   대화형 UI, 클라이언트 맞춤형 데이터 요청   3. 언제 어떤 기술을 선택해야 할까?: gRPC가 적합한 경우:  마이크로서비스 간 통신: 빠르고 효율적인 서비스 간 통신이 필요할 때 고성능 API: 네트워크 대역폭을 최적화하고 성능을 극대화해야 할 때 양방향 스트리밍 필요: 실시간 데이터 흐름이 중요한 경우 (예: 채팅, 스트리밍 서비스) 다양한 언어를 사용하는 환경: 여러 언어로 클라이언트를 개발해야 할 때REST가 적합한 경우:  웹 서비스 API: 브라우저 및 모바일 앱에서 쉽게 접근할 수 있는 API가 필요할 때 간단한 CRUD 서비스: 복잡한 기능 없이 간단한 데이터 전송이 필요한 경우 캐싱이 중요한 경우: REST API는 HTTP 캐싱을 지원하여 성능 최적화 가능GraphQL이 적합한 경우:  프론트엔드 맞춤형 데이터 제공: 클라이언트가 원하는 데이터만 받아야 하는 경우 오버페칭/언더페칭 문제 해결: REST API의 단점인 불필요한 데이터 전송 문제 해결 복잡한 관계형 데이터 처리: 여러 개의 API 요청을 하나로 합쳐야 할 때 (예: 대시보드 UI)4. 결론:       선택 기준   추천 기술         빠른 속도와 효율성   gRPC       간단한 웹 API   REST       프론트엔드 맞춤형 API   GraphQL       실시간 스트리밍   gRPC, GraphQL       마이크로서비스 간 통신   gRPC       기존 시스템과의 호환성   REST   각 기술은 특정 상황에서 장점을 발휘합니다. 단순한 CRUD API라면 REST가 적합하고, 프론트엔드 최적화를 원한다면 GraphQL이 좋은 선택입니다. 반면, 성능이 중요한 마이크로서비스 환경에서는 gRPC가 강력한 솔루션이 될 수 있습니다. 따라서, 사용하려는 서비스의 요구 사항을 분석하고 적절한 기술을 선택하는 것이 가장 중요합니다! 5. 질문 모음: Q. REST 의 장점이 캐싱이라니 다른 두개도 캐싱 할 수 있지않은가?: A. REST는 HTTP 캐싱을 기본적으로 지원하는 반면, gRPC와 GraphQL은 별도의 캐싱 전략이 필요해. : | 특징 | REST | gRPC | GraphQL ||———-|——–|——–|——–|| 기본 캐싱 지원 | ✅ (HTTP 캐싱) | ❌ (별도 구현 필요) | ❌ (별도 구현 필요) || 클라이언트 캐싱 | 가능 (브라우저, CDN) | 가능 (클라이언트 메모리) | 가능 (Apollo, Relay 등) || 서버 캐싱 | 가능 (Reverse Proxy) | 가능 (Redis, Memcached) | 가능 (Redis, Persisted Queries) | REST는 기본적으로 HTTP 캐싱을 활용할 수 있어서 쉽고 강력한 캐싱을 제공하지만,gRPC와 GraphQL도 적절한 캐싱 전략을 적용하면 성능을 개선할 수 있어. 1=&gt; 결국 나머지도 노오오력 하면 된다는거잖아. . Q. GraphQL 특징이 단일 엔드포인트라고 적혀있는데, 하나의 API 로 여러 리소스를 준다는 것인가?: A. 맞아! GraphQL의 단일 엔드포인트(single endpoint)란 하나의 API 요청으로 여러 리소스를 한 번에 가져올 수 있다는 의미야: REST 방식: REST에서는 각 리소스마다 개별적인 엔드포인트를 제공해. 예를 들어, 블로그의 게시글과 댓글 데이터를 가져오려면 두 번의 요청을 보내야 해. 1️⃣ 게시글 가져오기 (/posts/1) 1234567GET /posts/1{  id : 1,  title :  GraphQL vs REST ,  content :  REST와 GraphQL의 차이점. . .  ,  authorId : 100}2️⃣ 댓글 가져오기 (/posts/1/comments) 12345GET /posts/1/comments[ {  id : 201,  postId : 1,  content :  좋은 글이네요!  }, {  id : 202,  postId : 1,  content :  더 많은 예제가 있으면 좋겠어요.   }] REST 방식에서는 여러 개의 API 엔드포인트를 호출해야 필요한 데이터를 모두 가져올 수 있음 여러 번의 요청이 필요해서 네트워크 비용이 증가할 수 있음. GraphQL 방식: GraphQL에서는 단일 엔드포인트(/graphql)를 사용하고, 필요한 데이터를 한 번에 요청할 수 있어. 1️⃣ GraphQL 쿼리 123456789query { post(id: 1) {  title  content  comments {   content  } }} GraphQL에서는 한 번의 요청으로 여러 리소스를 가져올 수 있어! 네트워크 비용을 줄이고 필요한 데이터만 받을 수 있어서 효율적. 12=&gt; ??? 사실 REST 에서도 GraphQL 처럼 post API 요청 시 댓글도 다 줄 수 있지않나? 쿼리를 넣어도 되고. . . =&gt; 쿼리 파싱해서 뭐 분기하는게 불편할 수 있는데, GraphQL 도 비슷하게 구현될 것 같은데. . 아닌가 이건 안해봐서 모르겠다. 담에 해보고 생각해봐야지Q. 저번 테스트에 따르면 gRPC 같은 경우에는 클라이언트 친화적인 것 같지는 않거든? GraphQL 은 어때, 웹에서 쓰기에도 편하게 쓸 수 있어?: A. GraphQL은 웹에서 쓰기에 매우 편리한 API 방식이야!: gRPC는 클라이언트 친화적이지 않다는 단점이 있어. 이유를 살펴보면 다음과 같아:  바이너리 포맷 사용 (ProtoBuf) → 사람이 직접 읽고 쓰기 어려움 브라우저에서 직접 호출 불가능 → gRPC-Web 같은 추가적인 설정이 필요 REST처럼 간편한 요청이 어려움 → 클라이언트에서 Stub 코드 생성이 필요GraphQL이 클라이언트 친화적인 이유: 브라우저에서 쉽게 요청 가능:  REST API처럼 브라우저에서 직접 fetch 또는 Axios를 이용해 호출할 수 있음.  예를 들어, 다음과 같이 GraphQL 쿼리를 보낼 수 있어:  1234567891011121314fetch('/graphql', {method: 'POST',headers: { 'Content-Type': 'application/json' },body: JSON. stringify({ query: `{  post(id: 1) {   title   content  } }`})}). then(response =&gt; response. json()). then(data =&gt; console. log(data));   필요한 데이터만 선택해서 가져올 수 있음:  REST에서는 /users/1을 호출하면 불필요한 데이터를 포함한 전체 객체를 받아야 하지만, GraphQL에서는 특정 필드만 선택해서 받을 수 있음 → 오버페칭 방지123456query { user(id: 1) {  name  email }}프론트엔드 라이브러리 지원이 풍부함:  GraphQL은 Apollo Client, Relay 같은 라이브러리를 활용하면 클라이언트에서 편하게 사용할 수 있음.  Apollo Client를 사용하면 자동 캐싱과 쿼리 관리가 쉬워짐. 12345678910111213141516171819import { useQuery, gql } from '@apollo/client';const GET_POST = gql` query {  post(id: 1) {   title   content  } }`;function Post() { const { loading, error, data } = useQuery(GET_POST); if (loading) return &lt;p&gt;Loading. . . &lt;/p&gt;; if (error) return &lt;p&gt;Error: {error. message}&lt;/p&gt;; return &lt;h1&gt;{data. post. title}&lt;/h1&gt;;}Subscription(실시간 데이터) 지원:  GraphQL은 WebSocket을 사용한 Subscription을 지원해서 실시간 데이터를 쉽게 받을 수 있음.  예를 들어, 채팅 메시지나 알림 시스템을 만들 때 편리함. 결론: GraphQL은 클라이언트 친화적인가?:       기준   REST   gRPC   GraphQL         브라우저에서 직접 호출   ✅ 가능   ❌ 불가능 (gRPC-Web 필요)   ✅ 가능       필요한 데이터만 가져오기   ❌ 불가능 (고정된 응답)   ❌ 불가능   ✅ 가능       프론트엔드 라이브러리 지원   ✅ 일반적   ❌ 거의 없음   ✅ 풍부함 (Apollo, Relay 등)       실시간 데이터 (Subscription)   ❌ WebSocket 필요   ✅ 지원   ✅ 지원   ✔ gRPC는 클라이언트 친화적이지 않지만,✔ GraphQL은 웹 프론트엔드에서 매우 편리하게 사용할 수 있는 API 방식이야! 12345=&gt; 살짝만 봤는데, REST 랑 동작이 매우 비슷하다=&gt; 사용하는데에도 REST 랑 별 차이는 없을 듯=&gt; 직접 구현해봐야겠지만, 구현 난이도가 적다면 Front 용 API 는 이걸로 대체하는 것도 나쁘지는 않을 듯=&gt; 다만, 써봐야 알겠지만, 이게 Front 입장에서 과연 편할까?. . . 저거 직접 data 하나하나 명시하는거 귀찮을 것 같은데. . . =&gt; 근데 왜 REST 는 필요한 데이터만 가져오기가 불가능이지?. . 쿼리 파라미터에 추가로 필요한 데이터 넣어서 파싱하면 뭐 어찌저찌 가능하지않나, 아! 빼기가 안되나? ㅇㅈ내 생각: 1234기본적으로 그냥 REST 쓰면 딱히 손해보는 일은 없어 보인다. 다만, 저번 REST VS gRPC 포스트에서 적었듯이 서버끼리의 통신은 gRPC도 고려해볼만 할 것 같다. 프론트랑 통신은 REST VS GraphQL 인데, 이건 좀 더 테스트를 해봐야할 것 같다. 아직까지는 REST 를 버리고 갈만큼 매력적으로 다가오지않는다. "
    }, {
    "id": 9,
    "url": "http://localhost:4000/study/rest_vs_grpc/",
    "title": "REST vs gRPC 성능 비교: 정말 gRPC가 좋을까?",
    "body": "2025/03/09 -  gRPC는 REST보다 빠르다?뭔가 지나가다 들었던 것 같은데 gRPC가 REST보다 성능이 좋다고 했던 것 같다. 단순한 API 호출에서 성능 차이가 있을까?뭐. . 테스트 해보면 알겠지 확인해보자. 1차 테스트: REST API: 123456789@RestController@RequestMapping( /api )class RestTestController {  @GetMapping( /hello )  fun hello(): Mono&lt;Map&lt;String, String&gt;&gt; {    return Mono. just(mapOf( message  to  Hello from REST ))  }}gRPC: 12345678910111213141516syntax =  proto3 ;option java_multiple_files = true;option java_package =  com. example. grpc ;service HelloService { rpc SayHello (HelloRequest) returns (HelloResponse);}message HelloRequest { string name = 1;}message HelloResponse { string message = 1;}123456789101112@GrpcServiceclass HelloServiceImpl : HelloServiceGrpc. HelloServiceImplBase() {  override fun sayHello(request: HelloRequest, responseObserver: StreamObserver&lt;HelloResponse&gt;) {    val response = HelloResponse. newBuilder()      . setMessage( Hello from gRPC, ${request. name} )      . build()    responseObserver. onNext(response)    responseObserver. onCompleted()  }}테스트 코드: 1234567891011121314151617181920212223242526272829303132333435363738394041class GrpcRestPerformanceTest {  companion object {    private lateinit var restClient: WebClient    private lateinit var grpcStub: HelloServiceGrpc. HelloServiceBlockingStub    @JvmStatic    @BeforeAll    fun setup() {      restClient = WebClient. create( http://localhost:8080 )      val channel = ManagedChannelBuilder. forAddress( localhost , 9090)        . usePlaintext()        . build()      grpcStub = HelloServiceGrpc. newBlockingStub(channel)    }  }  @Test  fun testRestVsGrpcPerformance() {    val restTime = measureTimeMillis {      repeat(1000) {        restClient. get()          . uri( /api/test )          . retrieve()          . bodyToMono(String::class. java)          . block()      }    }    val grpcTime = measureTimeMillis {      repeat(1000) {        grpcStub. sayHello(HelloRequest. newBuilder(). setName( test ). build())      }    }    println( REST API 실행 시간: ${restTime}ms )    println( gRPC 실행 시간: ${grpcTime}ms )  }}결과: 12REST API 실행 시간: 728msgRPC 실행 시간: 493ms생각보다 별 차이가 안난다?. .  REST API 에 비해 gRPC 구성이 귀찮았다는 것을 생각해보면 생각보다 차이가 안나보인다 47% 정도 더 빠른 것 같긴한데, 의미가 있어보진 않는다. (뭐. . 이정도 차이는 네트워크 차이겠지. . 아닌가? 빠른 것 같기도?) 데이터 양이 너무 작아서 잘 안느껴지나? 좀 더 늘려보자2차 테스트 (데이터 추가): REST API: 123456789@GetMapping( /hello-big )fun helloBig(): Mono&lt;Map&lt;String, Any&gt;&gt; {  return Mono. just(    mapOf(       message  to  Hello from REST ,       dataList  to List(1000) {  Item $it  } // 1000개 데이터 추가    )  )}gRPC: 12345678service HelloService { rpc SayHelloBig (HelloRequest) returns (HelloBigResponse);}message HelloBigResponse { string message = 1; repeated string dataList = 2; // 데이터 추가}123456789override fun sayHelloBig(request: HelloRequest, responseObserver: StreamObserver&lt;HelloBigResponse&gt;) {  val response = HelloBigResponse. newBuilder()    . setMessage( Hello from gRPC, ${request. name} )    . addAllDataList(List(1000) {  Item $it  }) // 1000개 데이터 추가    . build()  responseObserver. onNext(response)  responseObserver. onCompleted()}테스트 코드: 123456789101112131415161718192021@Testfun testRestVsGrpcPerformance2() {  val restTime = measureTimeMillis {    repeat(1000) {      restClient. get()        . uri( /api/hello-big )        . retrieve()        . bodyToMono(String::class. java)        . block()    }  }  val grpcTime = measureTimeMillis {    repeat(1000) {      grpcStub. sayHelloBig(HelloRequest. newBuilder(). setName( test ). build())    }  }  println( REST API 실행 시간: ${restTime}ms )  println( gRPC 실행 시간: ${grpcTime}ms )}결과: 12REST API 실행 시간: 749msgRPC 실행 시간: 586ms???? 뭐지 왜 속도가 똑같지?… 아니 애초에 gRPC 만 속도가 늘었네, 이유가 뭐지. .  27% 더 빠르긴 한데, 이전보다 속도 차이가 줄었다.  간단한 String 이라지만 리스트 1000개를 보낼일이 거의 없다는 거 생각하면, 속도 차이는 없다고 봐도 될지도?… (그냥 Streaming 용 인가??…) 으음… 데이터가 늘었을 때, 속도차이가 줄었다. . 음. . 직렬화 비용이 gRPC 가 더 비싼가? cost 를 비교해볼까?. . 추가: 리소스는 누가 더 먹을까?: 데이터 크기 비교:  속도가 빠른 이유가 보내는 데이터가 더 적기 때문이지 않을까?테스트 코드: 12345678910111213141516171819202122232425262728@Testfun testApiNetworkUsage() {  val requestJson = objectMapper. writeValueAsBytes(mapOf( name  to  test ))  val restRequestSize = requestJson. size  val restResponseSize = measureTimeMillis {    val response = restClient. get()      . uri( /api/hello-big )      . retrieve()      . bodyToMono(String::class. java)      . block()    response?. toByteArray()?. size ?: 0  }  val grpcRequestProto = HelloRequest. newBuilder(). setName( test ). build(). toByteArray()  val grpcRequestSize = grpcRequestProto. size  val grpcResponseSize = measureTimeMillis {    val response = grpcStub. sayHelloBig(HelloRequest. newBuilder(). setName( test ). build())    response. toByteArray(). size  }  println( REST 요청 크기: ${restRequestSize} bytes )  println( REST 응답 크기: ${restResponseSize} bytes )  println( gRPC 요청 크기: ${grpcRequestSize} bytes )  println( gRPC 응답 크기: ${grpcResponseSize} bytes )}결과: 1234REST 요청 크기: 15 bytesREST 응답 크기: 135 bytesgRPC 요청 크기: 6 bytesgRPC 응답 크기: 73 bytes 오!! 실제로 데이터 크기가 작다 절반 정도로 작은 것은 좀 유의미해 보인다.  데이터 크기가 적은 만큼 빠르다 라고 보는게 맞을 것 같다.  gRPC 는 작은 크기로 직렬화 + 데이터 압축으로 네트워크 트래픽이 적다는 것 같다. CPU 사용량 테스트: 테스트 코드: 12345678910111213141516171819202122232425262728293031323334private fun getProcessCpuLoad(): Double {  val osBean = ManagementFactory. getOperatingSystemMXBean() as com. sun. management. OperatingSystemMXBean  return osBean. processCpuLoad * 100}@Testfun testRestApiCpuUsage() {  val cpuBefore = getProcessCpuLoad()  val timeTaken = measureTimeMillis {    repeat(1000) {      restClient. get()        . uri( /api/hello-big )        . retrieve()        . bodyToMono(String::class. java)        . block()    }  }  val cpuAfter = getProcessCpuLoad()  println( REST API 실행 시간: ${timeTaken}ms, CPU 사용량: ${cpuBefore}% → ${cpuAfter}% )}@Testfun testGrpcCpuUsage() {  val cpuBefore = getProcessCpuLoad()  val timeTaken = measureTimeMillis {    repeat(1000) {      grpcStub. sayHelloBig(HelloRequest. newBuilder(). setName( test ). build())    }  }  val cpuAfter = getProcessCpuLoad()  println( gRPC 실행 시간: ${timeTaken}ms, CPU 사용량: ${cpuBefore}% → ${cpuAfter}% )}결과: 12REST API 실행 시간: 565ms, CPU 사용량: 0. 0% → 13. 67082100502329%gRPC 실행 시간: 463ms, CPU 사용량: 0. 0% → 17. 609519673425176% 대략 30% 정도 CPU를 더 쓰는 것 같다.  왜일까?… 위에 데이터 크기가 줄어드는 것과 연관이 있을까? 데이터 직렬화 + 압축에 CPU를 좀 더 쓰는 것 같기도 하다?결론:       항목   REST   gRPC   차이점         속도   749ms   586ms   gRPC가 30% 더 빠름       요청 데이터 크기   15 bytes   6 bytes   gRPC가 2. 5배 더 작음       응답 데이터 크기   135 bytes   73 bytes   gRPC가 2배 더 작음       CPU 사용량   13. 6%   17. 6%   gRPC가 CPU를 30% 더 많이 사용함    요약:  HTTP/2 + Protobuf + 바이너리 직렬화로 gRPC 가 속도도 빠르고, 데이터 크기도 적다.  그로인한 오버헤드로 CPU 사용량이 더 많다.  CPU 리소스를 고려하지않아도 된다면, 서버 사이의 통신은 gRPC도 생각보다 고려해볼만 하다. "
    }, {
    "id": 10,
    "url": "http://localhost:4000/study/open/",
    "title": "새로운 시작",
    "body": "2025/03/09 - 블로그를 새로 만들었습니다. 앞으로는 공부하고 있는 것들을 하나하나 정리해보려고 합니다. 잘부탁드립니다. "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});